/// <reference path="../../DefinitelyTyped/bluebird/bluebird.d.ts" />
/// <reference path="../../DefinitelyTyped/node/node.d.ts" />
/// <reference path="../../DefinitelyTyped/request/request.d.ts" />

import request = require('request');
import promise = require('bluebird');
import http = require('http');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AccessTokenRequest {
    /**
    * one of code, password, refresh_token, client_credentials
    */
    "grantType": string;
    /**
    * Stewards Public Key
    */
    "clientId": string;
    /**
    * Client Secret
    */
    "clientSecret": string;
    "username": string;
    "password": string;
    "refreshToken": string;
}

export class AccountsGet extends GetResponse {
    "account": string;
    "accountNamespace": string;
    "currency": string;
    "currencyNamespace": string;
    /**
    * timestamp in milliseconds since epoch
    */
    "created": number;
    /**
    * stewardname of steward who made change
    */
    "createdBy": string;
    "modifications": Array<Modification>;
    "stewards": Array<string>;
    "publicKey": string;
}

export class AccountsList extends Array<AccountsGet> {
}

export class AccountsRequest {
    "account": string;
    "accountNamespace": string;
    "currency": string;
    "currencyNamespace": string;
    "stewards": Array<string>;
    "publicKey": string;
}

export class AccountsResponse {
    "account": string;
    "accountNamespace": string;
    "currency": string;
    "currencyNamespace": string;
    /**
    * timestamp in milliseconds since epoch
    */
    "created": number;
    /**
    * stewardname of steward who made change
    */
    "createdBy": string;
    "modifications": Array<Modification>;
    "stewards": Array<string>;
    "publicKey": string;
}

export class AesEncryption {
    "content": string;
    "tag": any;
}

export class ApplicationRequest {
    /**
    * Applications Name
    */
    "applicationName": string;
    /**
    * Applications home page
    */
    "homepageUri": string;
    /**
    * Application Description
    */
    "applicationDescription": string;
    /**
    * Callback url after authorization.
    */
    "authorizationCallbackUri": string;
}

export class ApplicationResponse {
    "applicationId": string;
    "applicationSecret": string;
}

export class CreateResponse {
    "id": string;
    "ok": boolean;
}

export class CurrenciesGet extends GetResponse {
    "currency": string;
    "currencyNamespace": string;
    /**
    * timestamp in milliseconds since epoch
    */
    "created": number;
    /**
    * stewardname of steward who made change
    */
    "createdBy": string;
    "modifications": Array<Modification>;
    "stewards": Array<string>;
}

export class CurrenciesList extends Array<CurrenciesGet> {
}

export class CurrenciesRequest {
    "currency": string;
    "currencyNamespace": string;
    "stewards": Array<string>;
}

export class CurrenciesResponse {
    "currency": string;
    "currencyNamespace": string;
    /**
    * timestamp in milliseconds since epoch
    */
    "created": number;
    /**
    * stewardname of steward who made change
    */
    "createdBy": string;
    "modifications": Array<Modification>;
    "stewards": Array<string>;
}

export class DeleteResponse {
    "id": string;
    "ok": boolean;
}

export class EncryptedJournals {
    "id": string;
    "type": string;
    "algorithm": string;
    "publicKeyEncryptedSymetricKey": string;
    "initializationVector": string;
    "encryptedJournal": AesEncryption;
}

export class ErrorModel {
    "code": number;
    "message": string;
}

export class GetResponse {
    "id": string;
}

export class JournalsList extends Array<EncryptedJournals> {
}

export class JournalsRequest {
    "toAccount": string;
    "toAccountNamespace": string;
    "amount": number;
}

export class JournalsResponse {
    "toAccount": string;
    "toAccountNamespace": string;
    "fromAccount": string;
    "fromAccountNamespace": string;
    "currency": string;
    "currencyNamespace": string;
    "amount": number;
    "created": number;
    /**
    * stewardname of who created entry
    */
    "createdBy": string;
}

export class Modification {
    /**
    * timestamp in milliseconds since epoch
    */
    "modified": number;
    /**
    * stewardname of steward who made modification
    */
    "modifiedBy": string;
    /**
    * human readable description of modification
    */
    "modification": string;
}

export class NamespacesGet extends GetResponse {
    "namespace": string;
    "parentNamespace": string;
    /**
    * timestamp in milliseconds since epoch
    */
    "created": number;
    /**
    * stewardname of who created space
    */
    "createdBy": string;
    "modifications": Array<Modification>;
    "stewards": Array<string>;
}

export class NamespacesList extends Array<NamespacesGet> {
}

export class NamespacesRequest {
    "namespace": string;
    "parentNamespace": string;
    "stewards": Array<string>;
}

export class NamespacesResponse {
    "namespace": string;
    "parentNamespace": string;
    /**
    * timestamp in milliseconds since epoch
    */
    "created": number;
    /**
    * stewardname of who created space
    */
    "createdBy": string;
    "modifications": Array<Modification>;
    "stewards": Array<string>;
}

export class OauthAuthorizeRequest {
    /**
    * One of code, password, refresh_token, client_credentials
    */
    "responseType": string;
    "clientId": string;
    /**
    * A uri to redirect steward after authorization
    */
    "redirectUri": string;
    /**
    * stewardname of user
    */
    "username": string;
    /**
    * A comma separated list of scopes. If not provided, scope defaults to an empty list of scopes for stewards that don\u2019t have a valid token for the app. For stewards who do already have a valid token for the app, the steward won\u2019t be shown the OAuth authorization page with the list of scopes. Instead, this step of the flow will automatically complete with the same scopes that were used last time the steward completed the flow.
    */
    "scopes": Array<string>;
}

export class RegisterRequest {
    /**
    * Stewards name
    */
    "stewardname": string;
    /**
    * Stewards password
    */
    "password": string;
    /**
    * Stewards 1024bit - 4096bit RSA public key. command: openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:4096 ,openssl rsa -pubout -in private_key.pem -out public_key.pem , you can deterministically generate an RSA key from a passphrase http://crypto.stackexchange.com/questions/24514/deterministically-generate-a-rsa-public-private-key-pair-from-a-passphrase-with you can also use this service to generate a key online: http://travistidwell.com/blog/2013/09/06/an-online-rsa-public-and-private-key-generator/
    */
    "publicKey": string;
    /**
    * Stewards email address
    */
    "email": string;
    /**
    * Does steward wish to receive email notifications
    */
    "emailNotifications": boolean;
}

export class RegisterResponse {
    "stewards": Array<StewardsGet>;
    "accounts": Array<AccountsGet>;
    "currencies": Array<CurrenciesGet>;
    "namespaces": Array<NamespacesGet>;
}

export class StewardsGet extends GetResponse {
    "stewardname": string;
    "publicKey": string;
    "email": string;
    "emailNotifications": boolean;
    /**
    * timestamp in milliseconds since epoch
    */
    "created": number;
    /**
    * stewardname of steward who made change
    */
    "createdBy": string;
    "modifications": Array<Modification>;
}

export class StewardsList extends Array<StewardsGet> {
}

export class StewardsRequest {
    "stewardname": string;
    "password": string;
    "publicKey": string;
    "email": string;
    "emailNotifications": boolean;
}

export class StewardsResponse {
    "stewardname": string;
    "publicKey": string;
    "email": string;
    "emailNotifications": boolean;
    /**
    * timestamp in milliseconds since epoch
    */
    "created": number;
    /**
    * stewardname of steward who made change
    */
    "createdBy": string;
    "modifications": Array<Modification>;
}

export class TokenResponse {
    "accessToken": string;
    "expires": string;
}


interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export class AccountsApi {
    protected basePath = 'https://cloud.openmoney.cc/V2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2PasswordSecurity': new OAuth(),
        'oauth2ImplicitSecurity': new OAuth(),
        'oauth2ApplicationSecurity': new OAuth(),
        'oauth2AccessCodeSecurity': new OAuth(),
        'apiKeySecurity': new ApiKeyAuth('header', 'Authorization'),
        'oauth2Refresh': new ApiKeyAuth('header', 'Authorization'),
        'basicAuthenticationSecurity': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.oauth2PasswordSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ImplicitSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ApplicationSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2AccessCodeSecurity.accessToken = token;
    }

    set apiKey(key: string) {
        this.authentications.apiKeySecurity.apiKey = key;
    }

    set apiKey(key: string) {
        this.authentications.oauth2Refresh.apiKey = key;
    }

    set username(username: string) {
        this.authentications.basicAuthenticationSecurity.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuthenticationSecurity.password = password;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete an account
     *
     * @param stewardname
     * @param namespace
     * @param account
     * @param authorization Authorization Token
     */
    public accountsDelete (stewardname: string, namespace: string, account: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: DeleteResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/accounts/{account}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'account' + '}', String(account));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling accountsDelete');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling accountsDelete');
        }

        // verify required parameter 'account' is set
        if (!account) {
            throw new Error('Missing required parameter account when calling accountsDelete');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DeleteResponse;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Lookup an account by it&#39;s public key
     *
     * @param stewardname
     * @param authorization Authorization Token
     * @param publicKey Accounts public Key
     */
    public accountsDiscovery (stewardname: string, authorization?: string, publicKey?: string) : Promise<{ response: http.ClientResponse; body: AccountsResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/accounts/lookup'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling accountsDiscovery');
        }

        if (publicKey !== undefined) {
            queryParameters['publicKey'] = publicKey;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: AccountsResponse;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Get an account by account name
     *
     * @param stewardname
     * @param namespace
     * @param account
     * @param currency
     * @param currencyNamespace
     * @param authorization Authorization Token
     */
    public accountsGet (stewardname: string, namespace: string, account: string, currency: string, currencyNamespace: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: AccountsGet;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/accounts/{account}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'account' + '}', String(account));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling accountsGet');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling accountsGet');
        }

        // verify required parameter 'account' is set
        if (!account) {
            throw new Error('Missing required parameter account when calling accountsGet');
        }

        // verify required parameter 'currency' is set
        if (!currency) {
            throw new Error('Missing required parameter currency when calling accountsGet');
        }

        // verify required parameter 'currencyNamespace' is set
        if (!currencyNamespace) {
            throw new Error('Missing required parameter currencyNamespace when calling accountsGet');
        }

        if (currency !== undefined) {
            queryParameters['currency'] = currency;
        }

        if (currencyNamespace !== undefined) {
            queryParameters['currency_namespace'] = currencyNamespace;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: AccountsGet;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Get a Listing of accounts in a namespace
     *
     * @param stewardname
     * @param namespace
     * @param currency
     * @param currencyNamespace
     * @param authorization Authorization Token
     */
    public accountsList (stewardname: string, namespace: string, currency: string, currencyNamespace: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: AccountsList;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/accounts'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling accountsList');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling accountsList');
        }

        // verify required parameter 'currency' is set
        if (!currency) {
            throw new Error('Missing required parameter currency when calling accountsList');
        }

        // verify required parameter 'currencyNamespace' is set
        if (!currencyNamespace) {
            throw new Error('Missing required parameter currencyNamespace when calling accountsList');
        }

        if (currency !== undefined) {
            queryParameters['currency'] = currency;
        }

        if (currencyNamespace !== undefined) {
            queryParameters['currency_namespace'] = currencyNamespace;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: AccountsList;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * create an account in a namespace
     *
     * @param stewardname
     * @param namespace
     * @param authorization Authorization Token
     * @param account
     */
    public accountsPost (stewardname: string, namespace: string, authorization?: string, account?: AccountsRequest) : Promise<{ response: http.ClientResponse; body: DeleteResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/accounts'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling accountsPost');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling accountsPost');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DeleteResponse;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: account,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Update an account
     *
     * @param stewardname
     * @param namespace
     * @param account Account Name
     * @param authorization Authorization Token
     * @param accounts
     */
    public accountsPut (stewardname: string, namespace: string, account: string, authorization?: string, accounts?: AccountsRequest) : Promise<{ response: http.ClientResponse; body: CreateResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/accounts/{account}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'account' + '}', String(account));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling accountsPut');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling accountsPut');
        }

        // verify required parameter 'account' is set
        if (!account) {
            throw new Error('Missing required parameter account when calling accountsPut');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CreateResponse;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: accounts,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class AuthApi {
    protected basePath = 'https://cloud.openmoney.cc/V2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2PasswordSecurity': new OAuth(),
        'oauth2ImplicitSecurity': new OAuth(),
        'oauth2ApplicationSecurity': new OAuth(),
        'oauth2AccessCodeSecurity': new OAuth(),
        'apiKeySecurity': new ApiKeyAuth('header', 'Authorization'),
        'oauth2Refresh': new ApiKeyAuth('header', 'Authorization'),
        'basicAuthenticationSecurity': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.oauth2PasswordSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ImplicitSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ApplicationSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2AccessCodeSecurity.accessToken = token;
    }

    set apiKey(key: string) {
        this.authentications.apiKeySecurity.apiKey = key;
    }

    set apiKey(key: string) {
        this.authentications.oauth2Refresh.apiKey = key;
    }

    set username(username: string) {
        this.authentications.basicAuthenticationSecurity.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuthenticationSecurity.password = password;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get Steward account information
     *
     * @param stewardname
     */
    public accountGet (stewardname: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/account'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling accountGet');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Login Page for the steward
     *
     * @param stewardname
     */
    public loginGet (stewardname: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/login'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling loginGet');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: string;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Login steward
     *
     * @param stewardname
     * @param authorization
     */
    public loginPost (stewardname: string, authorization?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/login'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling loginPost');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Logout steward
     *
     * @param stewardname
     */
    public logoutPost (stewardname: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/logout'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling logoutPost');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Exchanges the user or client credentials for an access token used to access resources.
     *
     * @param stewardname
     * @param accessTokenRequest Access Token Request Object
     * @param authorization
     */
    public oauthAccessTokenPost (stewardname: string, accessTokenRequest: AccessTokenRequest, authorization?: string) : Promise<{ response: http.ClientResponse; body: TokenResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/oauth/token'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling oauthAccessTokenPost');
        }

        // verify required parameter 'accessTokenRequest' is set
        if (!accessTokenRequest) {
            throw new Error('Missing required parameter accessTokenRequest when calling oauthAccessTokenPost');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: TokenResponse;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: accessTokenRequest,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2Refresh.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Create an application for a client_id and client_secret for oauth token authorization.
     * Existing steward Registers an application with the openmoney network.
     * @param stewardname
     * @param application Application Object
     * @param authorization
     */
    public oauthApplicationPost (stewardname: string, application: ApplicationRequest, authorization?: string) : Promise<{ response: http.ClientResponse; body: ApplicationResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/oauth/application'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling oauthApplicationPost');
        }

        // verify required parameter 'application' is set
        if (!application) {
            throw new Error('Missing required parameter application when calling oauthApplicationPost');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: ApplicationResponse;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: application,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Implicit authorization dialog presented to steward to authorize client_id to access API resources on their behalf.
     *
     * @param stewardname
     * @param clientId Client ID received during registration
     * @param redirectUri A uri to redirect steward after authorization
     * @param scopes A comma separated list of scopes. If not provided, scope defaults to an empty list of scopes for stewards that don\u2019t have a valid token for the app. For stewards who do already have a valid token for the app, the steward won\u2019t be shown the OAuth authorization page with the list of scopes. Instead, this step of the flow will automatically complete with the same scopes that were used last time the steward completed the flow.
     */
    public oauthDialogeGet (stewardname: string, clientId: string, redirectUri?: string, scopes?: Array<string>) : Promise<{ response: http.ClientResponse; body: ErrorModel;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/dialog/authorize'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling oauthDialogeGet');
        }

        // verify required parameter 'clientId' is set
        if (!clientId) {
            throw new Error('Missing required parameter clientId when calling oauthDialogeGet');
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (redirectUri !== undefined) {
            queryParameters['redirect_uri'] = redirectUri;
        }

        if (scopes !== undefined) {
            queryParameters['scopes'] = scopes;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: ErrorModel;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Authorizes a steward on the openmoney network
     * Authorization dialoge decision with allowed scopes.
     * @param stewardname
     * @param oauthAuthorizeRequest
     */
    public oauthDialogePost (stewardname: string, oauthAuthorizeRequest: OauthAuthorizeRequest) : Promise<{ response: http.ClientResponse; body: ErrorModel;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/dialog/authorize/decision'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling oauthDialogePost');
        }

        // verify required parameter 'oauthAuthorizeRequest' is set
        if (!oauthAuthorizeRequest) {
            throw new Error('Missing required parameter oauthAuthorizeRequest when calling oauthDialogePost');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: ErrorModel;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: oauthAuthorizeRequest,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class CurrenciesApi {
    protected basePath = 'https://cloud.openmoney.cc/V2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2PasswordSecurity': new OAuth(),
        'oauth2ImplicitSecurity': new OAuth(),
        'oauth2ApplicationSecurity': new OAuth(),
        'oauth2AccessCodeSecurity': new OAuth(),
        'apiKeySecurity': new ApiKeyAuth('header', 'Authorization'),
        'oauth2Refresh': new ApiKeyAuth('header', 'Authorization'),
        'basicAuthenticationSecurity': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.oauth2PasswordSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ImplicitSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ApplicationSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2AccessCodeSecurity.accessToken = token;
    }

    set apiKey(key: string) {
        this.authentications.apiKeySecurity.apiKey = key;
    }

    set apiKey(key: string) {
        this.authentications.oauth2Refresh.apiKey = key;
    }

    set username(username: string) {
        this.authentications.basicAuthenticationSecurity.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuthenticationSecurity.password = password;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a currency
     *
     * @param stewardname
     * @param namespace
     * @param currency Currency name
     * @param authorization Authorization Token
     */
    public currenciesDelete (stewardname: string, namespace: string, currency: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: DeleteResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/currencies/{currency}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'currency' + '}', String(currency));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling currenciesDelete');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling currenciesDelete');
        }

        // verify required parameter 'currency' is set
        if (!currency) {
            throw new Error('Missing required parameter currency when calling currenciesDelete');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DeleteResponse;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Get a currency by its name
     *
     * @param stewardname
     * @param namespace
     * @param currency Name of a currency
     * @param authorization Authorization Token
     */
    public currenciesGet (stewardname: string, namespace: string, currency: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: CurrenciesGet;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/currencies/{currency}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'currency' + '}', String(currency));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling currenciesGet');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling currenciesGet');
        }

        // verify required parameter 'currency' is set
        if (!currency) {
            throw new Error('Missing required parameter currency when calling currenciesGet');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CurrenciesGet;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Get a Listing currencies known by steward.
     *
     * @param stewardname
     * @param namespace
     * @param authorization Authorization Token
     */
    public currenciesList (stewardname: string, namespace: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: CurrenciesList;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/currencies'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling currenciesList');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling currenciesList');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CurrenciesList;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Create a currency
     *
     * @param stewardname
     * @param namespace
     * @param authorization Authorization Token
     * @param currency
     */
    public currenciesPost (stewardname: string, namespace: string, authorization?: string, currency?: CurrenciesRequest) : Promise<{ response: http.ClientResponse; body: CreateResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/currencies'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling currenciesPost');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling currenciesPost');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CreateResponse;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: currency,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Update a Currency
     *
     * @param stewardname
     * @param namespace
     * @param currency Name of a currency
     * @param authorization Authorization Token
     * @param currencies
     */
    public currenciesPut (stewardname: string, namespace: string, currency: string, authorization?: string, currencies?: CurrenciesRequest) : Promise<{ response: http.ClientResponse; body: CreateResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/currencies/{currency}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'currency' + '}', String(currency));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling currenciesPut');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling currenciesPut');
        }

        // verify required parameter 'currency' is set
        if (!currency) {
            throw new Error('Missing required parameter currency when calling currenciesPut');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CreateResponse;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: currencies,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class JournalsApi {
    protected basePath = 'https://cloud.openmoney.cc/V2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2PasswordSecurity': new OAuth(),
        'oauth2ImplicitSecurity': new OAuth(),
        'oauth2ApplicationSecurity': new OAuth(),
        'oauth2AccessCodeSecurity': new OAuth(),
        'apiKeySecurity': new ApiKeyAuth('header', 'Authorization'),
        'oauth2Refresh': new ApiKeyAuth('header', 'Authorization'),
        'basicAuthenticationSecurity': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.oauth2PasswordSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ImplicitSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ApplicationSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2AccessCodeSecurity.accessToken = token;
    }

    set apiKey(key: string) {
        this.authentications.apiKeySecurity.apiKey = key;
    }

    set apiKey(key: string) {
        this.authentications.oauth2Refresh.apiKey = key;
    }

    set username(username: string) {
        this.authentications.basicAuthenticationSecurity.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuthenticationSecurity.password = password;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List Journal Entries for this accountname
     *
     * @param stewardname
     * @param namespace
     * @param account
     * @param currency
     * @param authorization Authorization Token
     * @param currencyNamespace
     * @param offset
     * @param range
     */
    public journalsList (stewardname: string, namespace: string, account: string, currency: string, authorization?: string, currencyNamespace?: string, offset?: number, range?: number) : Promise<{ response: http.ClientResponse; body: JournalsList;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/accounts/{account}/journals/{currency}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'account' + '}', String(account))
            .replace('{' + 'currency' + '}', String(currency));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling journalsList');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling journalsList');
        }

        // verify required parameter 'account' is set
        if (!account) {
            throw new Error('Missing required parameter account when calling journalsList');
        }

        // verify required parameter 'currency' is set
        if (!currency) {
            throw new Error('Missing required parameter currency when calling journalsList');
        }

        if (currencyNamespace !== undefined) {
            queryParameters['currency_namespace'] = currencyNamespace;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (range !== undefined) {
            queryParameters['range'] = range;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: JournalsList;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Create a journal entry for this account
     *
     * @param stewardname
     * @param namespace
     * @param account
     * @param currency
     * @param authorization Authorization Token
     * @param currencyNamespace
     * @param journal
     */
    public journalsPost (stewardname: string, namespace: string, account: string, currency: string, authorization?: string, currencyNamespace?: string, journal?: JournalsRequest) : Promise<{ response: http.ClientResponse; body: CreateResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}/accounts/{account}/journals/{currency}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace))
            .replace('{' + 'account' + '}', String(account))
            .replace('{' + 'currency' + '}', String(currency));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling journalsPost');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling journalsPost');
        }

        // verify required parameter 'account' is set
        if (!account) {
            throw new Error('Missing required parameter account when calling journalsPost');
        }

        // verify required parameter 'currency' is set
        if (!currency) {
            throw new Error('Missing required parameter currency when calling journalsPost');
        }

        if (currencyNamespace !== undefined) {
            queryParameters['currency_namespace'] = currencyNamespace;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CreateResponse;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: journal,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class NamespacesApi {
    protected basePath = 'https://cloud.openmoney.cc/V2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2PasswordSecurity': new OAuth(),
        'oauth2ImplicitSecurity': new OAuth(),
        'oauth2ApplicationSecurity': new OAuth(),
        'oauth2AccessCodeSecurity': new OAuth(),
        'apiKeySecurity': new ApiKeyAuth('header', 'Authorization'),
        'oauth2Refresh': new ApiKeyAuth('header', 'Authorization'),
        'basicAuthenticationSecurity': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.oauth2PasswordSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ImplicitSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ApplicationSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2AccessCodeSecurity.accessToken = token;
    }

    set apiKey(key: string) {
        this.authentications.apiKeySecurity.apiKey = key;
    }

    set apiKey(key: string) {
        this.authentications.oauth2Refresh.apiKey = key;
    }

    set username(username: string) {
        this.authentications.basicAuthenticationSecurity.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuthenticationSecurity.password = password;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     *
     * Delete a namespace
     * @param stewardname
     * @param namespace namespace name
     * @param authorization Authorization Token
     */
    public spacesDelete (stewardname: string, namespace: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: DeleteResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling spacesDelete');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling spacesDelete');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DeleteResponse;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Get a namespace by it&#39;s name
     *
     * @param stewardname
     * @param namespace space name
     * @param authorization Authorization Token
     */
    public spacesGet (stewardname: string, namespace: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: NamespacesGet;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling spacesGet');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling spacesGet');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: NamespacesGet;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Get a Listing of namespaces known by steward.
     *
     * @param stewardname
     * @param authorization Authorization Token
     * @param parentNamespace
     */
    public spacesList (stewardname: string, authorization?: string, parentNamespace?: string) : Promise<{ response: http.ClientResponse; body: NamespacesList;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling spacesList');
        }

        if (parentNamespace !== undefined) {
            queryParameters['parent_namespace'] = parentNamespace;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: NamespacesList;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Create a namespace
     *
     * @param stewardname
     * @param space
     * @param authorization Authorization Token
     */
    public spacesPost (stewardname: string, space: NamespacesRequest, authorization?: string) : Promise<{ response: http.ClientResponse; body: CreateResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling spacesPost');
        }

        // verify required parameter 'space' is set
        if (!space) {
            throw new Error('Missing required parameter space when calling spacesPost');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CreateResponse;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: space,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Update a namespace
     *
     * @param stewardname
     * @param namespace space name
     * @param authorization Authorization Token
     * @param space
     */
    public spacesPut (stewardname: string, namespace: string, authorization?: string, space?: NamespacesRequest) : Promise<{ response: http.ClientResponse; body: CreateResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}/namespaces/{namespace}'
            .replace('{' + 'stewardname' + '}', String(stewardname))
            .replace('{' + 'namespace' + '}', String(namespace));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling spacesPut');
        }

        // verify required parameter 'namespace' is set
        if (!namespace) {
            throw new Error('Missing required parameter namespace when calling spacesPut');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CreateResponse;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: space,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export class StewardsApi {
    protected basePath = 'https://cloud.openmoney.cc/V2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth2PasswordSecurity': new OAuth(),
        'oauth2ImplicitSecurity': new OAuth(),
        'oauth2ApplicationSecurity': new OAuth(),
        'oauth2AccessCodeSecurity': new OAuth(),
        'apiKeySecurity': new ApiKeyAuth('header', 'Authorization'),
        'oauth2Refresh': new ApiKeyAuth('header', 'Authorization'),
        'basicAuthenticationSecurity': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.oauth2PasswordSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ImplicitSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2ApplicationSecurity.accessToken = token;
    }

    set accessToken(token: string) {
        this.authentications.oauth2AccessCodeSecurity.accessToken = token;
    }

    set apiKey(key: string) {
        this.authentications.apiKeySecurity.apiKey = key;
    }

    set apiKey(key: string) {
        this.authentications.oauth2Refresh.apiKey = key;
    }

    set username(username: string) {
        this.authentications.basicAuthenticationSecurity.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuthenticationSecurity.password = password;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a steward account
     *
     * @param stewardname
     * @param authorization
     */
    public stewardsDelete (stewardname: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: DeleteResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling stewardsDelete');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DeleteResponse;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Get a single steward
     *
     * @param stewardname
     * @param authorization
     */
    public stewardsGet (stewardname: string, authorization?: string) : Promise<{ response: http.ClientResponse; body: StewardsGet;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling stewardsGet');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: StewardsGet;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Get a listing of known stewards
     *
     * @param authorization
     */
    public stewardsList (authorization?: string) : Promise<{ response: http.ClientResponse; body: StewardsList;  }> {
        const localVarPath = this.basePath + '/stewards';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: StewardsList;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Register a steward on the system
     *
     * @param registerRequest Registration Request
     */
    public stewardsPost (registerRequest: RegisterRequest) : Promise<{ response: http.ClientResponse; body: RegisterResponse;  }> {
        const localVarPath = this.basePath + '/stewards';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'registerRequest' is set
        if (!registerRequest) {
            throw new Error('Missing required parameter registerRequest when calling stewardsPost');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: RegisterResponse;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: registerRequest,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * Update a steward account
     *
     * @param stewardname
     * @param steward Steward Document
     * @param authorization
     */
    public stewardsPut (stewardname: string, steward: StewardsRequest, authorization?: string) : Promise<{ response: http.ClientResponse; body: CreateResponse;  }> {
        const localVarPath = this.basePath + '/stewards/{stewardname}'
            .replace('{' + 'stewardname' + '}', String(stewardname));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stewardname' is set
        if (!stewardname) {
            throw new Error('Missing required parameter stewardname when calling stewardsPut');
        }

        // verify required parameter 'steward' is set
        if (!steward) {
            throw new Error('Missing required parameter steward when calling stewardsPut');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: CreateResponse;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: steward,
        }

        this.authentications.basicAuthenticationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2PasswordSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ApplicationSecurity.applyToRequest(requestOptions);

        this.authentications.oauth2ImplicitSecurity.applyToRequest(requestOptions);

        this.authentications.apiKeySecurity.applyToRequest(requestOptions);

        this.authentications.oauth2AccessCodeSecurity.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
